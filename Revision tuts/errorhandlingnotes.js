/*

Tips: Global Error handling middleware is the only one who serves the errors which are caught by
      different errror handling function and middlewares
      
      Global Error handling mainly makes sure further middlewares will not progressed and the error object which is created will
      be served by global error handling middleware

      Global Error handling middleware serves info about the error based on the the enivronments and the type of errors
      we must define all those type of servings for different envs and differnt erros as like in 
      errorcontroller.js


// default routes must be mentioned always after defined routes

app.all('*',(req,res,next)=>{})

.all - can be any type of request get/post/... the route handler function to this route will be sending the response

* - It can take the place of any url/route request except for the once which are defined

=>* How error handling works for Operational Errors?

Point1 :Generally the default route handler function is always a error response for undefined routes

Point2 : the default route handler function will create an error object out of defined/in built error class and pass it through next function

Point3 : Whenever the next function call of middleware carries an error parameter it will be direct it to the
global error handling middlewre

//Global error handling middleware    app.use((error,req,res,next)=>{    _(Code for serving the error)_         })

*The error parameter above is the err which will be passed inside any next(err) function call 


Generally Global error handler function will serve errors whenever it detects a next(err) call with error
parameter in it


As soon as it triggers then further middlewares will not progressed and the error object which is created will
be served by global error handling middleware


In our Code
here the error for undefined routes,asyncerrors(rejected promiese) were served  

Serving of errors was done in a different format for development environment and production environment

In production environment it was again differently served for Operational and non Operatoinal errors







 //Custom error Class

We use our defined Error Class(pre defined in Node) and create custom error class in Summary
we make an custom error class by inherting the properties of Error Class which is predifined in Node

Ex: We made an custom error class for showing Operational errors 

//Creating a custom error class which is also using the features of our built in error class

class CustomError extends Error{

constructor(message,statusCode){

super(message); //constructor of our inherited class

this.statusCode=statusCode;
this.status = statusCode >=400 && statusCode<500 ? 'fail' : 'error'; //status between 400 to 499 code is fail
                                                                    //or else it error

this.isOperational=true; // this class is only for opertational errors

Error.captureStackTrace(this,this.constructor); // the error class automatically detects where the error has occured

}



}

//The way we call our constructor of the class

//const error= new CustomError('some error message',404)


module.exports= CustomError;

// Why Custom Error in our Code?   **

In Point 2 of our "how error handling works for Operational Errors" there we have created an error object out of a inbuilt Error Class
here in Custom Error Class we are Inheriting the same inbuilt Error Class and making a better Error Class
for handling operational errors and making the error object out of our Custom error class and passing
it through next function

//Async Error Handler function 

Made to decrease burden of catching errors using catch method 

we have created a seperate error handling function which will catch the errors and improve the 
perfomace of Event handling for a client request


//We are passing our create method handler function as an argument using func
module.exports = (func)=>{   // As our createmovie handler must only deal with the create method
    //than dealing with catch method to find error simuntaneously
    //we created a seperate error handler for catching errors for it
return(req,res,next)=>{                                    
func(req,res,next).catch(err=> next(err));  //when the function returns a rejected promise catch function
          //calls next(err) which calls global error handler function
}
}

Ex: 

exports.createmovie= asyncErrorHandler( async (req,res)=>{ _logic_   })


// Not found errors  - If any event is not handled logically correctly then such errors occur

In our code the following Not found error occured which was solved by a error handling logic

In getbyid request we are getting success response for a id similar to the format of mongodb autogenerated id and
is does not match any document for which we must get an error

//change2  


if(!movie){ // when id is similar and success is the statud movies data field will be assigned null so
                                    //!null should be the if condition to correct such error(logic)

const error= new CustomError('Movie with that id is not found',404);

return next(error);



}
























*/